import { useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';
import { useXR } from './xr.js';
export function useHover(ref, onChange) {
    let setHover;
    let hover;
    if (onChange == null) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const [_hover, _setHover] = useState(false);
        setHover = _setHover;
        hover = _hover;
    }
    else {
        setHover = onChange;
    }
    useEffect(() => {
        const { current } = ref;
        if (current == null) {
            return;
        }
        const set = new Set();
        const enter = (e) => {
            if (set.size === 0) {
                setHover(true);
            }
            set.add(e.pointerId);
        };
        const leave = (e) => {
            set.delete(e.pointerId);
            if (set.size === 0) {
                setHover(false);
            }
        };
        current.addEventListener('pointerenter', enter);
        current.addEventListener('pointerleave', leave);
        return () => {
            current.removeEventListener('pointerenter', enter);
            current.removeEventListener('pointerleave', leave);
        };
    }, [ref, setHover]);
    return hover;
}
/**
 * hook for getting the session visibility state
 */
export function useXRSessionVisibilityState() {
    return useXR((xr) => xr.visibilityState);
}
/**
 * hook for getting the function to initialize the room capture for scanning the room
 */
export function useInitRoomCapture() {
    return useXR((xr) => xr.session?.initiateRoomCapture?.bind(xr.session));
}
/**
 * hook for checking if a session mode is supported
 * @param onError callback executed when an error happens while checking if the session mode is supported
 */
export function useSessionModeSupported(mode, onError) {
    const onErrorRef = useRef(onError);
    onErrorRef.current = onError;
    const [subscribe, getSnapshot] = useMemo(() => {
        let sessionSupported = undefined;
        return [
            (onChange) => {
                let canceled = false;
                if (typeof navigator === 'undefined' || navigator.xr == null) {
                    sessionSupported = false;
                    return () => { };
                }
                navigator.xr
                    .isSessionSupported(mode)
                    .then((isSupported) => {
                    sessionSupported = isSupported;
                    if (canceled) {
                        return;
                    }
                    onChange();
                })
                    .catch((e) => {
                    if (canceled) {
                        return;
                    }
                    onErrorRef.current?.(e);
                });
                return () => (canceled = true);
            },
            () => sessionSupported,
        ];
    }, [mode]);
    return useSyncExternalStore(subscribe, getSnapshot);
}
export function useSessionFeatureEnabled(feature) {
    return useXR(({ session }) => session?.enabledFeatures?.includes(feature) ?? false);
}
