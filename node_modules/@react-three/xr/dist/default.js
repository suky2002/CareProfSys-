import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, createTeleportRayLine, syncTeleportPointerRayGroup, buildTeleportTargetFilter, } from '@pmndrs/xr/internals';
import { useRef, Suspense, useContext, useMemo } from 'react';
import { XRControllerModel } from './controller.js';
import { XRHandModel } from './hand.js';
import { CombinedPointer, PointerCursorModel, PointerRayModel, useGrabPointer, useLinesPointer, usePointerXRInputSourceEvents, useRayPointer, useTouchPointer, } from './pointer.js';
import { XRSpace as XRSpaceImpl } from './space.js';
import { xrInputSourceStateContext } from './contexts.js';
import { TeleportPointerRayModel } from './teleport.js';
import { createPortal, useFrame, useThree } from '@react-three/fiber';
import { useXRInputSourceStateContext } from './input.js';
export { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, } from '@pmndrs/xr/internals';
function DefaultXRInputSourceGrabPointer(event, spaceType, options) {
    const state = useContext(xrInputSourceStateContext);
    if (state == null) {
        throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);
    }
    const ref = useRef(null);
    const pointer = useGrabPointer(ref, state, options);
    usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);
    const cursorModelOptions = options.cursorModel;
    return (_jsx(XRSpaceImpl, { ref: ref, space: spaceType, children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) })) }));
}
/**
 * grab pointer for the XRHand
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `makeDefault` used the set the default pointer inside a combined pointer
 * - `cursorModel` properties for configuring how the cursor should look
 * - `radius` the size of the intersection sphere
 */
export const DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'select', 'index-finger-tip');
/**
 * grab pointer for the XRController
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `makeDefault` used the set the default pointer inside a combined pointer
 * - `cursorModel` properties for configuring how the cursor should look
 * - `radius` the size of the intersection sphere
 */
export const DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'squeeze', 'grip-space');
/**
 * ray pointer for the XRInputSource
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `makeDefault` used the set the default pointer inside a combined pointer
 * - `radius` the size of the intersection sphere
 * - `minDistance` minimal distance to trigger interactions
 * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line
 * - `direction` the direction of the ray
 * - `rayModel` properties for configuring how the ray should look
 * - `cursorModel` properties for configuring how the cursor should look
 */
export function DefaultXRInputSourceRayPointer(options) {
    const state = useXRInputSourceStateContext();
    const ref = useRef(null);
    const pointer = useRayPointer(ref, state, options);
    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);
    const rayModelOptions = options.rayModel;
    const cursorModelOptions = options.cursorModel;
    return (_jsxs(XRSpaceImpl, { ref: ref, space: "target-ray-space", children: [rayModelOptions !== false && (_jsx(PointerRayModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }));
}
/**
 * touch pointer for the XRHand
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `makeDefault` used the set the default pointer inside a combined pointer
 * - `cursorModel` properties for configuring how the cursor should look
 * - `hoverRadius` the size of the intersection sphere
 * - `downRadius` the distance to the touch center to trigger a pointerdown event
 * - `button` the id of the button that is triggered when touching
 */
export function DefaultXRHandTouchPointer(options) {
    const state = useXRInputSourceStateContext('hand');
    const ref = useRef(null);
    const pointer = useTouchPointer(ref, state, options);
    const cursorModelOptions = options.cursorModel;
    return (_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.hand.get('index-finger-tip'), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) })) }));
}
/**
 * default controller implementation with grab and ray pointers
 *
 * properties
 * - `model` options for configuring the controller apperance
 * - `grabPointer` options for configuring the grab pointer
 * - `rayPointer` options for configuring the ray pointer
 */
export function DefaultXRController(options) {
    const modelOptions = options.model;
    const grabPointerOptions = options.grabPointer;
    const rayPointerOptions = options.rayPointer;
    const teleportPointerOptions = options.teleportPointer ?? false;
    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRControllerModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));
}
/**
 * default hand implementation with touch, grab and ray pointers
 *
 * properties
 * - `model` options for configuring the hand appearance
 * - `grabPointer` options for configuring the grab pointer
 * - `rayPointer` options for configuring the ray pointer
 * - `touchPointer` options for configuring the touch pointer
 */
export function DefaultXRHand(options) {
    const modelOptions = options.model;
    const grabPointerOptions = options.grabPointer;
    const rayPointerOptions = options.rayPointer;
    const touchPointerOptions = options.touchPointer;
    const teleportPointerOptions = options.teleportPointer ?? false;
    const rayPointerRayModelOptions = rayPointerOptions === false ? false : spreadable(rayPointerOptions)?.rayModel;
    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRHandModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && _jsx(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));
}
/**
 * default transient-pointer implementation with ray pointer
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `minDistance` minimal distance to trigger interactions
 * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line
 * - `direction` the direction of the ray
 * - `cursorModel` properties for configuring how the cursor should look
 */
export function DefaultXRTransientPointer(options) {
    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });
}
/**
 * default gaze implementation with ray pointer
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `minDistance` minimal distance to trigger interactions
 * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line
 * - `direction` the direction of the ray
 * - `cursorModel` properties for configuring how the cursor should look
 */
export function DefaultXRGaze(options) {
    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });
}
/**
 * default screen-input implementation with ray pointer
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `minDistance` minimal distance to trigger interactions
 * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line
 * - `direction` the direction of the ray
 */
export function DefaultXRScreenInput(options) {
    return _jsx(DefaultXRInputSourceRayPointer, { ...options, cursorModel: false, rayModel: false });
}
/**
 * telport pointer for the XRInputSource
 * emits a downwards bend ray that only interesects with meshes marked as teleportable
 *
 * properties
 * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event
 * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event
 * - `contextMenuButton` the button that triggers contextmenu events
 * - `makeDefault` used the set the default pointer inside a combined pointer
 * - `radius` the size of the intersection sphere
 * - `minDistance` minimal distance to trigger interactions
 * - `direction` the direction of the ray
 * - `rayModel` properties for configuring how the ray should look
 * - `cursorModel` properties for configuring how the cursor should look
 */
export function DefaultXRInputSourceTeleportPointer(options) {
    const state = useContext(xrInputSourceStateContext);
    if (state == null) {
        throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);
    }
    const ref = useRef(null);
    const groupRef = useRef(null);
    const linePoints = useMemo(() => createTeleportRayLine(), []);
    const pointer = useLinesPointer(groupRef, state, {
        ...options,
        linePoints,
        filter: buildTeleportTargetFilter(options),
    }, 'teleport');
    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);
    const rayModelOptions = options.rayModel;
    const cursorModelOptions = options.cursorModel;
    const scene = useThree((state) => state.scene);
    const cursorRef = useRef(null);
    useFrame((_, delta) => {
        if (cursorRef.current != null) {
            cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;
        }
        const target = groupRef.current;
        const source = ref.current;
        if (target == null || source == null) {
            return;
        }
        syncTeleportPointerRayGroup(source, target, delta * 1000);
    });
    return (_jsxs(_Fragment, { children: [_jsx(XRSpaceImpl, { ref: ref, space: "target-ray-space" }), createPortal(_jsxs("group", { ref: groupRef, children: [rayModelOptions !== false && (_jsx(TeleportPointerRayModel, { linePoints: linePoints, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { ref: cursorRef, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }), scene)] }));
}
function spreadable(value) {
    if (value === true) {
        return undefined;
    }
    return value;
}
