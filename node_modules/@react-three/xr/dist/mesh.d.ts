import { BufferGeometry, Mesh } from 'three';
/**
 * component for rendering a mesh for the XRMesh based on the detected mesh geometry
 */
export declare const XRMeshModel: import("react").ForwardRefExoticComponent<Omit<Omit<import("@react-three/fiber").ExtendedColors<import("@react-three/fiber").Overwrite<Partial<Mesh<BufferGeometry<import("three").NormalBufferAttributes>, import("three").Material | import("three").Material[], import("three").Object3DEventMap>>, import("@react-three/fiber").NodeProps<Mesh<BufferGeometry<import("three").NormalBufferAttributes>, import("three").Material | import("three").Material[], import("three").Object3DEventMap>, typeof Mesh>>>, import("@react-three/fiber").NonFunctionKeys<{
    position?: import("@react-three/fiber").Vector3;
    up?: import("@react-three/fiber").Vector3;
    scale?: import("@react-three/fiber").Vector3;
    rotation?: import("@react-three/fiber").Euler;
    matrix?: import("@react-three/fiber").Matrix4;
    quaternion?: import("@react-three/fiber").Quaternion;
    layers?: import("@react-three/fiber").Layers;
    dispose?: (() => void) | null;
}>> & {
    position?: import("@react-three/fiber").Vector3;
    up?: import("@react-three/fiber").Vector3;
    scale?: import("@react-three/fiber").Vector3;
    rotation?: import("@react-three/fiber").Euler;
    matrix?: import("@react-three/fiber").Matrix4;
    quaternion?: import("@react-three/fiber").Quaternion;
    layers?: import("@react-three/fiber").Layers;
    dispose?: (() => void) | null;
} & import("@react-three/fiber/dist/declarations/src/core/events.js").EventHandlers & {
    mesh: XRMesh;
}, "ref"> & import("react").RefAttributes<Mesh<BufferGeometry<import("three").NormalBufferAttributes>, import("three").Material | import("three").Material[], import("three").Object3DEventMap>>>;
/**
 * hook for getting all dected meshes with the provided semantic label
 */
export declare function useXRMeshes(semanticLabel?: string): readonly XRMesh[];
/**
 * hook for getting the geometry from the detected mesh
 * @param mesh the detected mesh
 * @param disposeBuffer allows to disable auto disposing the geometry buffer
 */
export declare function useXRMeshGeometry(mesh: XRMesh, disposeBuffer?: boolean): BufferGeometry;
