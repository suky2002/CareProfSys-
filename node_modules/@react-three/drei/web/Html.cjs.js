"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("react-dom/client"),n=require("three"),o=require("@react-three/fiber");function i(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var s=i(t),a=i(r);const c=new n.Vector3,l=new n.Vector3,u=new n.Vector3,d=new n.Vector2;function m(e,t,r){const n=c.setFromMatrixPosition(e.matrixWorld);n.project(t);const o=r.width/2,i=r.height/2;return[n.x*o+o,-n.y*i+i]}const f=e=>Math.abs(e)<1e-10?0:e;function h(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=f(t[r]*e.elements[r])+(15!==r?",":")");return r+n}const p=(x=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>h(e,x));var x;const v=(e,t)=>{return h(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],"translate(-50%,-50%)");var r};const y=s.forwardRef((({children:t,eps:r=.001,style:i,className:h,prepend:x,center:y,fullscreen:g,portal:M,distanceFactor:P,sprite:b=!1,transform:w=!1,occlude:E,onOcclude:W,castShadow:S,receiveShadow:$,material:z,geometry:R,zIndexRange:j=[16777271,0],calculatePosition:F=m,as:O="div",wrapperClass:C,pointerEvents:T="auto",...I},A)=>{const{gl:k,camera:H,scene:N,size:V,raycaster:q,events:L,viewport:D}=o.useThree(),[_]=s.useState((()=>document.createElement(O))),G=s.useRef(),Z=s.useRef(null),B=s.useRef(0),J=s.useRef([0,0]),K=s.useRef(null),Q=s.useRef(null),U=(null==M?void 0:M.current)||L.connected||k.domElement.parentNode,X=s.useRef(null),Y=s.useRef(!1),ee=s.useMemo((()=>E&&"blending"!==E||Array.isArray(E)&&E.length&&function(e){return e&&"object"==typeof e&&"current"in e}(E[0])),[E]);s.useLayoutEffect((()=>{const e=k.domElement;E&&"blending"===E?(e.style.zIndex=`${Math.floor(j[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[E]),s.useLayoutEffect((()=>{if(Z.current){const e=G.current=a.createRoot(_);if(N.updateMatrixWorld(),w)_.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=F(Z.current,H,V);_.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return U&&(x?U.prepend(_):U.appendChild(_)),()=>{U&&U.removeChild(_),e.unmount()}}}),[U,w]),s.useLayoutEffect((()=>{C&&(_.className=C)}),[C]);const te=s.useMemo((()=>w?{position:"absolute",top:0,left:0,width:V.width,height:V.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:y?"translate3d(-50%,-50%,0)":"none",...g&&{top:-V.height/2,left:-V.width/2,width:V.width,height:V.height},...i}),[i,y,g,V,w]),re=s.useMemo((()=>({position:"absolute",pointerEvents:T})),[T]);s.useLayoutEffect((()=>{var e,r;(Y.current=!1,w)?null==(e=G.current)||e.render(s.createElement("div",{ref:K,style:te},s.createElement("div",{ref:Q,style:re},s.createElement("div",{ref:A,className:h,style:i,children:t})))):null==(r=G.current)||r.render(s.createElement("div",{ref:A,style:te,className:h,children:t}))}));const ne=s.useRef(!0);o.useFrame((e=>{if(Z.current){H.updateMatrixWorld(),Z.current.updateWorldMatrix(!0,!1);const e=w?J.current:F(Z.current,H,V);if(w||Math.abs(B.current-H.zoom)>r||Math.abs(J.current[0]-e[0])>r||Math.abs(J.current[1]-e[1])>r){const t=function(e,t){const r=c.setFromMatrixPosition(e.matrixWorld),n=l.setFromMatrixPosition(t.matrixWorld),o=r.sub(n),i=t.getWorldDirection(u);return o.angleTo(i)>Math.PI/2}(Z.current,H);let r=!1;ee&&(Array.isArray(E)?r=E.map((e=>e.current)):"blending"!==E&&(r=[N]));const o=ne.current;if(r){const e=function(e,t,r,n){const o=c.setFromMatrixPosition(e.matrixWorld),i=o.clone();i.project(t),d.set(i.x,i.y),r.setFromCamera(d,t);const s=r.intersectObjects(n,!0);if(s.length){const e=s[0].distance;return o.distanceTo(r.ray.origin)<e}return!0}(Z.current,H,q,r);ne.current=e&&!t}else ne.current=!t;o!==ne.current&&(W?W(!ne.current):_.style.display=ne.current?"block":"none");const i=Math.floor(j[0]/2),s=E?ee?[j[0],i]:[i-1,0]:j;if(_.style.zIndex=`${function(e,t,r){if(t instanceof n.PerspectiveCamera||t instanceof n.OrthographicCamera){const n=c.setFromMatrixPosition(e.matrixWorld),o=l.setFromMatrixPosition(t.matrixWorld),i=n.distanceTo(o),s=(r[1]-r[0])/(t.far-t.near),a=r[1]-s*t.far;return Math.round(s*i+a)}}(Z.current,H,s)}`,w){const[e,t]=[V.width/2,V.height/2],r=H.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:o,left:i,bottom:s,right:a}=H,c=p(H.matrixWorldInverse),l=n?`scale(${r})translate(${f(-(a+i)/2)}px,${f((o+s)/2)}px)`:`translateZ(${r}px)`;let u=Z.current.matrixWorld;b&&(u=H.matrixWorldInverse.clone().transpose().copyPosition(u).scale(Z.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),_.style.width=V.width+"px",_.style.height=V.height+"px",_.style.perspective=n?"":`${r}px`,K.current&&Q.current&&(K.current.style.transform=`${l}${c}translate(${e}px,${t}px)`,Q.current.style.transform=v(u,1/((P||10)/400)))}else{const t=void 0===P?1:function(e,t){if(t instanceof n.OrthographicCamera)return t.zoom;if(t instanceof n.PerspectiveCamera){const r=c.setFromMatrixPosition(e.matrixWorld),n=l.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,i=r.distanceTo(n);return 1/(2*Math.tan(o/2)*i)}return 1}(Z.current,H)*P;_.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}J.current=e,B.current=H.zoom}}if(!ee&&X.current&&!Y.current)if(w){if(K.current){const e=K.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=H;if(t||R)I.scale&&(Array.isArray(I.scale)?I.scale instanceof n.Vector3?X.current.scale.copy(I.scale.clone().divideScalar(1)):X.current.scale.set(1/I.scale[0],1/I.scale[1],1/I.scale[2]):X.current.scale.setScalar(1/I.scale));else{const t=(P||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;X.current.scale.set(r,n,1)}Y.current=!0}}}else{const t=_.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/D.factor,r=t.clientWidth*e,n=t.clientHeight*e;X.current.scale.set(r,n,1),Y.current=!0}X.current.lookAt(e.camera.position)}}));const oe=s.useMemo((()=>({vertexShader:w?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[w]);return s.createElement("group",e({},I,{ref:Z}),E&&!ee&&s.createElement("mesh",{castShadow:S,receiveShadow:$,ref:X},R||s.createElement("planeGeometry",null),z||s.createElement("shaderMaterial",{side:n.DoubleSide,vertexShader:oe.vertexShader,fragmentShader:oe.fragmentShader})))}));exports.Html=y;
