"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("three"),n=require("@react-three/fiber"),a=require("./Texture.cjs.js"),o=require("uuid"),u=require("../helpers/deprecated.cjs.js");function c(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var i=c(t);const s=new r.Matrix4,l=new r.Vector3,d=new r.Quaternion,m=new r.Vector3,f=new r.Quaternion,p=new r.Vector3,g=i.createContext(null),h=i.forwardRef((({children:t,material:o=r.MeshLambertMaterial,texture:c="https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",range:h,limit:y=200,frustumCulled:x,...v},b)=>{var M,w;const C=i.useMemo((()=>class extends o{constructor(){super();const e=parseInt(r.REVISION.replace(/\D+/g,""))>=154?"opaque_fragment":"output_fragment";this.onBeforeCompile=t=>{t.vertexShader="attribute float cloudOpacity;\n               varying float vOpacity;\n              "+t.vertexShader.replace("#include <fog_vertex>","#include <fog_vertex>\n                 vOpacity = cloudOpacity;\n                "),t.fragmentShader="varying float vOpacity;\n              "+t.fragmentShader.replace(`#include <${e}>`,`#include <${e}>\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\n                `)}}}),[o]);n.extend({CloudMaterial:C});const E=i.useRef(null),O=i.useRef([]),A=i.useMemo((()=>new Float32Array(Array.from({length:y},(()=>1)))),[y]),R=i.useMemo((()=>new Float32Array(Array.from({length:y},(()=>[1,1,1])).flat())),[y]),j=a.useTexture(c);let U,V=0,q=0;const F=new r.Quaternion,S=new r.Vector3(0,0,1),D=new r.Vector3;n.useFrame(((e,t)=>{for(V=e.clock.getElapsedTime(),s.copy(E.current.matrixWorld).invert(),e.camera.matrixWorld.decompose(m,f,p),q=0;q<O.current.length;q++)U=O.current[q],U.ref.current.matrixWorld.decompose(l,d,p),l.add(D.copy(U.position).applyQuaternion(d).multiply(p)),d.copy(f).multiply(F.setFromAxisAngle(S,U.rotation+=t*U.rotationFactor)),p.multiplyScalar(U.volume+(1+Math.sin(V*U.density*U.speed))/2*U.growth),U.matrix.compose(l,d,p).premultiply(s),U.dist=l.distanceTo(m);for(O.current.sort(((e,t)=>t.dist-e.dist)),q=0;q<O.current.length;q++)U=O.current[q],A[q]=U.opacity*(U.dist<U.fade-1?U.dist/U.fade:1),E.current.setMatrixAt(q,U.matrix),E.current.setColorAt(q,U.color);E.current.geometry.attributes.cloudOpacity.needsUpdate=!0,E.current.instanceMatrix.needsUpdate=!0,E.current.instanceColor&&(E.current.instanceColor.needsUpdate=!0)})),i.useLayoutEffect((()=>{const e=Math.min(y,void 0!==h?h:y,O.current.length);E.current.count=e,u.setUpdateRange(E.current.instanceMatrix,{offset:0,count:16*e}),E.current.instanceColor&&u.setUpdateRange(E.current.instanceColor,{offset:0,count:3*e}),u.setUpdateRange(E.current.geometry.attributes.cloudOpacity,{offset:0,count:e})}));let I=[null!==(M=j.image.width)&&void 0!==M?M:1,null!==(w=j.image.height)&&void 0!==w?w:1];const L=Math.max(I[0],I[1]);return I=[I[0]/L,I[1]/L],i.createElement("group",e({ref:b},v),i.createElement(g.Provider,{value:O},t,i.createElement("instancedMesh",{matrixAutoUpdate:!1,ref:E,args:[null,null,y],frustumCulled:x},i.createElement("instancedBufferAttribute",{usage:r.DynamicDrawUsage,attach:"instanceColor",args:[R,3]}),i.createElement("planeGeometry",{args:[...I]},i.createElement("instancedBufferAttribute",{usage:r.DynamicDrawUsage,attach:"attributes-cloudOpacity",args:[A,1]})),i.createElement("cloudMaterial",{key:o.name,map:j,transparent:!0,depthWrite:!1}))))})),y=i.forwardRef((({opacity:t=1,speed:a=0,bounds:u=[5,1,1],segments:c=20,color:s="#ffffff",fade:l=10,volume:d=6,smallestVolume:m=.25,distribute:f=null,growth:p=4,concentrate:h="inside",seed:y=Math.random(),...x},v)=>{function b(){const e=1e4*Math.sin(y++);return e-Math.floor(e)}const M=i.useContext(g),w=i.useRef(null),[C]=i.useState((()=>o.v4())),E=i.useMemo((()=>[...new Array(c)].map(((e,t)=>({segments:c,bounds:new r.Vector3(1,1,1),position:new r.Vector3,uuid:C,index:t,ref:w,dist:0,matrix:new r.Matrix4,color:new r.Color,rotation:t*(Math.PI/c)})))),[c,C]);return i.useLayoutEffect((()=>{E.forEach(((e,r)=>{n.applyProps(e,{volume:d,color:s,speed:a,growth:p,opacity:t,fade:l,bounds:u,density:Math.max(.5,b()),rotationFactor:Math.max(.2,.5*b())*a});const o=null==f?void 0:f(e,r);var i;(o||c>1)&&e.position.copy(e.bounds).multiply(null!==(i=null==o?void 0:o.point)&&void 0!==i?i:{x:2*b()-1,y:2*b()-1,z:2*b()-1});const g=Math.abs(e.position.x),y=Math.abs(e.position.y),x=Math.abs(e.position.z),v=Math.max(g,y,x);e.length=1,g===v&&(e.length-=g/e.bounds.x),y===v&&(e.length-=y/e.bounds.y),x===v&&(e.length-=x/e.bounds.z),e.volume=(void 0!==(null==o?void 0:o.volume)?o.volume:Math.max(Math.max(0,m),"random"===h?b():"inside"===h?e.length:1-e.length))*d}))}),[h,u,l,s,t,p,d,y,c,a]),i.useLayoutEffect((()=>{const e=E;return M.current=[...M.current,...e],()=>{M.current=M.current.filter((e=>e.uuid!==C))}}),[E]),i.useImperativeHandle(v,(()=>w.current),[]),i.createElement("group",e({ref:w},x))})),x=i.forwardRef(((t,r)=>i.useContext(g)?i.createElement(y,e({ref:r},t)):i.createElement(h,null,i.createElement(y,e({ref:r},t)))));exports.Cloud=x,exports.CloudInstance=y,exports.Clouds=h;
